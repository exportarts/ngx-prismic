{"version":3,"file":"asTree.cjs","sources":["../../src/asTree.ts"],"sourcesContent":["import {\n\tRichTextNodeType,\n\tRTAnyNode,\n\tRTBlockNode,\n\tRTInlineNode,\n\tRTListItemNode,\n\tRTNode,\n\tRTOListItemNode,\n\tRTTextNode,\n} from \"@prismicio/types\";\nimport { Tree, TreeNode } from \"./types\";\n\nconst uuid = (): string => {\n\treturn (++uuid.i).toString();\n};\nuuid.i = 0;\n\n/**\n * Parses a rich text or title field into a tree\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages. Most users aren't expected to this function directly.\n * @param nodes - A rich text or title field from Prismic\n *\n * @returns Tree from given rich text or title field\n */\nexport const asTree = (nodes: RTNode[]): Tree => {\n\tconst preparedNodes = prepareNodes(nodes);\n\n\tconst children: TreeNode[] = [];\n\tfor (let i = 0; i < preparedNodes.length; i++) {\n\t\tchildren.push(nodeToTreeNode(preparedNodes[i]));\n\t}\n\n\treturn {\n\t\tkey: uuid(),\n\t\tchildren,\n\t};\n};\n\nconst createTreeNode = (\n\tnode: RTAnyNode,\n\tchildren: TreeNode[] = [],\n): TreeNode => {\n\treturn {\n\t\tkey: uuid(),\n\t\ttype: node.type,\n\t\ttext: \"text\" in node ? node.text : undefined,\n\t\tnode,\n\t\tchildren,\n\t};\n};\n\nconst createTextTreeNode = (text: string): TreeNode => {\n\treturn createTreeNode({\n\t\ttype: RichTextNodeType.span,\n\t\ttext,\n\t\tspans: [],\n\t});\n};\n\nconst prepareNodes = (nodes: RTNode[]): RTBlockNode[] => {\n\tconst mutNodes: RTBlockNode[] = nodes.slice(0);\n\n\tfor (let i = 0; i < mutNodes.length; i++) {\n\t\tconst node = mutNodes[i];\n\n\t\tif (\n\t\t\tnode.type === RichTextNodeType.listItem ||\n\t\t\tnode.type === RichTextNodeType.oListItem\n\t\t) {\n\t\t\tconst items: (RTListItemNode | RTOListItemNode)[] = [\n\t\t\t\tnode as RTListItemNode | RTOListItemNode,\n\t\t\t];\n\n\t\t\twhile (mutNodes[i + 1] && mutNodes[i + 1].type === node.type) {\n\t\t\t\titems.push(mutNodes[i + 1] as RTListItemNode | RTOListItemNode);\n\t\t\t\tmutNodes.splice(i, 1);\n\t\t\t}\n\n\t\t\tif (node.type === RichTextNodeType.listItem) {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.list,\n\t\t\t\t\titems: items as RTListItemNode[],\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.oList,\n\t\t\t\t\titems: items as RTOListItemNode[],\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\treturn mutNodes;\n};\n\nconst nodeToTreeNode = (node: RTBlockNode): TreeNode => {\n\tif (\"text\" in node) {\n\t\treturn createTreeNode(\n\t\t\tnode,\n\t\t\ttextNodeSpansToTreeNodeChildren(node.spans, node),\n\t\t);\n\t}\n\n\tif (\"items\" in node) {\n\t\tconst children: TreeNode[] = [];\n\t\tfor (let i = 0; i < node.items.length; i++) {\n\t\t\tchildren.push(nodeToTreeNode(node.items[i]));\n\t\t}\n\n\t\treturn createTreeNode(node, children);\n\t}\n\n\treturn createTreeNode(node);\n};\n\nconst textNodeSpansToTreeNodeChildren = (\n\tspans: RTInlineNode[],\n\tnode: RTTextNode,\n\tparentSpan?: RTInlineNode,\n): TreeNode[] => {\n\tif (!spans.length) {\n\t\treturn [createTextTreeNode(node.text)];\n\t}\n\n\tconst mutSpans: RTInlineNode[] = spans.slice(0);\n\n\t// Sort spans using the following criteria:\n\t//\n\t//   1. By start index (ascending)\n\t//   2. If start indices are equal, by end index (descending)\n\t//\n\t// If start and end indices of more than one span are equal, use what\n\t// the API gives without modifications.\n\t//\n\t// Sorting using this algorithm ensures proper detection of child\n\t// spans.\n\tmutSpans.sort((a, b) => a.start - b.start || b.end - a.end);\n\n\tconst children: TreeNode[] = [];\n\n\tfor (let i = 0; i < mutSpans.length; i++) {\n\t\tconst span = mutSpans[i];\n\t\tconst parentSpanStart = (parentSpan && parentSpan.start) || 0;\n\t\tconst spanStart = span.start - parentSpanStart;\n\t\tconst spanEnd = span.end - parentSpanStart;\n\t\tconst text = node.text.slice(spanStart, spanEnd);\n\n\t\tconst childSpans: RTInlineNode[] = [];\n\t\tfor (let j = i; j < mutSpans.length; j++) {\n\t\t\tconst siblingSpan = mutSpans[j];\n\n\t\t\tif (siblingSpan !== span) {\n\t\t\t\tif (siblingSpan.start >= span.start && siblingSpan.end <= span.end) {\n\t\t\t\t\tchildSpans.push(siblingSpan);\n\t\t\t\t\tmutSpans.splice(j, 1);\n\t\t\t\t\tj--;\n\t\t\t\t} else if (\n\t\t\t\t\tsiblingSpan.start < span.end &&\n\t\t\t\t\tsiblingSpan.end > span.start\n\t\t\t\t) {\n\t\t\t\t\tchildSpans.push({\n\t\t\t\t\t\t...siblingSpan,\n\t\t\t\t\t\tend: span.end,\n\t\t\t\t\t});\n\t\t\t\t\tmutSpans[j] = {\n\t\t\t\t\t\t...siblingSpan,\n\t\t\t\t\t\tstart: span.end,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (i === 0 && spanStart > 0) {\n\t\t\tchildren.push(createTextTreeNode(node.text.slice(0, spanStart)));\n\t\t}\n\n\t\tconst spanWithText = { ...span, text };\n\t\tchildren.push(\n\t\t\tcreateTreeNode(\n\t\t\t\tspanWithText,\n\t\t\t\ttextNodeSpansToTreeNodeChildren(\n\t\t\t\t\tchildSpans,\n\t\t\t\t\t{\n\t\t\t\t\t\t...node,\n\t\t\t\t\t\ttext,\n\t\t\t\t\t},\n\t\t\t\t\tspan,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\tif (spanEnd < node.text.length) {\n\t\t\tchildren.push(\n\t\t\t\tcreateTextTreeNode(\n\t\t\t\t\tnode.text.slice(\n\t\t\t\t\t\tspanEnd,\n\t\t\t\t\t\tmutSpans[i + 1]\n\t\t\t\t\t\t\t? mutSpans[i + 1].start - parentSpanStart\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t}\n\n\treturn children;\n};\n"],"names":["RichTextNodeType"],"mappings":"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"}