"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const richtext = require("@prismicio/richtext");
const serializerHelpers = require("../lib/serializerHelpers.cjs");
const createDefaultHTMLRichTextSerializer = (linkResolver) => {
  return (_type, node, text, children, _key) => {
    switch (node.type) {
      case richtext.Element.heading1:
        return serializerHelpers.serializeStandardTag("h1", node, children);
      case richtext.Element.heading2:
        return serializerHelpers.serializeStandardTag("h2", node, children);
      case richtext.Element.heading3:
        return serializerHelpers.serializeStandardTag("h3", node, children);
      case richtext.Element.heading4:
        return serializerHelpers.serializeStandardTag("h4", node, children);
      case richtext.Element.heading5:
        return serializerHelpers.serializeStandardTag("h5", node, children);
      case richtext.Element.heading6:
        return serializerHelpers.serializeStandardTag("h6", node, children);
      case richtext.Element.paragraph:
        return serializerHelpers.serializeStandardTag("p", node, children);
      case richtext.Element.preformatted:
        return serializerHelpers.serializePreFormatted(node);
      case richtext.Element.strong:
        return serializerHelpers.serializeStandardTag("strong", node, children);
      case richtext.Element.em:
        return serializerHelpers.serializeStandardTag("em", node, children);
      case richtext.Element.listItem:
        return serializerHelpers.serializeStandardTag("li", node, children);
      case richtext.Element.oListItem:
        return serializerHelpers.serializeStandardTag("li", node, children);
      case richtext.Element.list:
        return serializerHelpers.serializeStandardTag("ul", node, children);
      case richtext.Element.oList:
        return serializerHelpers.serializeStandardTag("ol", node, children);
      case richtext.Element.image:
        return serializerHelpers.serializeImage(linkResolver, node);
      case richtext.Element.embed:
        return serializerHelpers.serializeEmbed(node);
      case richtext.Element.hyperlink:
        return serializerHelpers.serializeHyperlink(linkResolver, node, children);
      case richtext.Element.label:
        return serializerHelpers.serializeStandardTag("span", node, children);
      case richtext.Element.span:
      default:
        return serializerHelpers.serializeSpan(text);
    }
  };
};
const wrapMapSerializerWithStringChildren = (mapSerializer) => {
  const modifiedMapSerializer = {};
  for (const tag in mapSerializer) {
    const tagSerializer = mapSerializer[tag];
    if (tagSerializer) {
      modifiedMapSerializer[tag] = (payload) => {
        return tagSerializer({
          ...payload,
          // @ts-expect-error - merging blockSerializer types causes TS to bail to a never type
          children: payload.children.join("")
        });
      };
    }
  }
  return richtext.wrapMapSerializer(modifiedMapSerializer);
};
const asHTML = (richTextField, ...configObjectOrTuple) => {
  if (richTextField) {
    const [configObjectOrLinkResolver, maybeSerializer] = configObjectOrTuple;
    let config;
    if (typeof configObjectOrLinkResolver === "function" || configObjectOrLinkResolver == null) {
      config = {
        linkResolver: configObjectOrLinkResolver,
        serializer: maybeSerializer
      };
    } else {
      config = { ...configObjectOrLinkResolver };
    }
    let serializer;
    if (config.serializer) {
      serializer = richtext.composeSerializers(typeof config.serializer === "object" ? wrapMapSerializerWithStringChildren(config.serializer) : (type, node, text, children, key) => (
        // TypeScript doesn't narrow the type correctly here since it is now in a callback function, so we have to cast it here.
        config.serializer(type, node, text, children.join(""), key)
      ), createDefaultHTMLRichTextSerializer(config.linkResolver));
    } else {
      serializer = createDefaultHTMLRichTextSerializer(config.linkResolver);
    }
    return richtext.serialize(richTextField, serializer).join("");
  } else {
    return null;
  }
};
exports.asHTML = asHTML;
//# sourceMappingURL=asHTML.cjs.map
