{"version":3,"file":"unstable_mapSliceZone.cjs","sources":["../../../src/helpers/unstable_mapSliceZone.ts"],"sourcesContent":["import { Slice } from \"../types/value/slice\";\n\n/**\n * Convert a value to a lazyily loaded module. This is useful when using\n * functions like `() => import(\"...\")`.\n */\ntype LazyModule<T> = () => Promise<T | { default: T }>;\n\n/**\n * Mark a type as potentially lazy-loaded via a module.\n */\ntype MaybeLazyModule<T> = T | LazyModule<T>;\n\n/**\n * Returns the type of a `SliceLike` type.\n *\n * @typeParam Slice - The Slice from which the type will be extracted.\n */\ntype ExtractSliceType<TSlice extends SliceLike> = TSlice extends Slice\n\t? TSlice[\"slice_type\"]\n\t: TSlice extends SliceLikeGraphQL\n\t? TSlice[\"type\"]\n\t: never;\n\n/**\n * The minimum required properties to represent a Prismic Slice from the Prismic\n * Rest API V2 for the `unstable_mapSliceZone()` helper.\n *\n * @typeParam SliceType - Type name of the Slice.\n */\ntype SliceLikeRestV2<TSliceType extends string = string> = Pick<\n\tSlice<TSliceType>,\n\t\"id\" | \"slice_type\"\n>;\n\n/**\n * The minimum required properties to represent a Prismic Slice from the Prismic\n * GraphQL API for the `unstable_mapSliceZone()` helper.\n *\n * @typeParam SliceType - Type name of the Slice.\n */\ntype SliceLikeGraphQL<TSliceType extends string = string> = {\n\ttype: Slice<TSliceType>[\"slice_type\"];\n};\n\n/**\n * The minimum required properties to represent a Prismic Slice for the\n * `unstable_mapSliceZone()` helper.\n *\n * If using Prismic's Rest API V2, use the `Slice` export from\n * `@prismicio/client` for a full interface.\n *\n * @typeParam SliceType - Type name of the Slice.\n */\ntype SliceLike<TSliceType extends string = string> =\n\t| SliceLikeRestV2<TSliceType>\n\t| SliceLikeGraphQL<TSliceType>;\n\n/**\n * A looser version of the `SliceZone` type from `@prismicio/client` using\n * `SliceLike`.\n *\n * If using Prismic's Rest API V2, use the `SliceZone` export from\n * `@prismicio/client` for the full type.\n *\n * @typeParam TSlice - The type(s) of a Slice in the Slice Zone.\n */\ntype SliceZoneLike<TSlice extends SliceLike = SliceLike> = readonly TSlice[];\n\n/**\n * A set of properties that identify a Slice as having been mapped. Consumers of\n * the mapped Slice Zone can use these properties to detect and specially handle\n * mapped Slices.\n */\ntype MappedSliceLike = {\n\t/**\n\t * If `true`, this Slice has been modified from its original value using a\n\t * mapper.\n\t *\n\t * @internal\n\t */\n\t__mapped: true;\n};\n\n/**\n * Arguments for a function mapping content from a Prismic Slice using the\n * `unstable_mapSliceZone()` helper.\n *\n * @typeParam TSlice - The Slice passed as a prop.\n * @typeParam TContext - Arbitrary data passed to `unstable_mapSliceZone()` and\n *   made available to all Slice mappers.\n */\ntype SliceMapperArgs<\n\tTSlice extends SliceLike = SliceLike,\n\tTContext = unknown,\n> = {\n\t/**\n\t * Slice data.\n\t */\n\tslice: TSlice;\n\n\t/**\n\t * The index of the Slice in the Slice Zone.\n\t */\n\tindex: number;\n\n\t/**\n\t * All Slices from the Slice Zone to which the Slice belongs.\n\t */\n\t// TODO: We have to keep this list of Slices general due to circular\n\t// reference limtiations. If we had another generic to determine the full\n\t// union of Slice types, it would include TSlice. This causes TypeScript to\n\t// throw a compilation error.\n\tslices: SliceZoneLike<\n\t\tTSlice extends SliceLikeGraphQL ? SliceLikeGraphQL : SliceLikeRestV2\n\t>;\n\n\t/**\n\t * Arbitrary data passed to `unstable_mapSliceZone()` and made available to\n\t * all Slice mappers.\n\t */\n\tcontext: TContext;\n};\n\n/**\n * A record of mappers.\n */\nexport type Mappers<\n\tTSlice extends SliceLike = SliceLike,\n\tTContext = unknown,\n> = {\n\t[P in ExtractSliceType<TSlice>]: MaybeLazyModule<\n\t\tMapper<\n\t\t\tExtract<TSlice, SliceLike<P>>,\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tany,\n\t\t\tTContext\n\t\t>\n\t>;\n};\n\n/**\n * A function that maps a Slice and its metadata to a modified version. The\n * return value will replace the Slice in the Slice Zone.\n */\nexport type Mapper<\n\tTSlice extends SliceLike = SliceLike,\n\tTMappedSlice extends Record<string, unknown> | undefined | void =\n\t\t| Record<string, unknown>\n\t\t| undefined\n\t\t| void,\n\tTContext = unknown,\n> = (\n\targs: MapperArgs<TSlice, TContext>,\n) => TMappedSlice | Promise<TMappedSlice>;\n\n/**\n * Arguments provided to a mapper function.\n */\nexport type MapperArgs<\n\tTSlice extends SliceLike = SliceLike,\n\tTContext = unknown,\n> = SliceMapperArgs<TSlice, TContext>;\n\n/**\n * Unwraps a lazily loaded mapper module.\n */\ntype ResolveLazyMapperModule<TMapper extends Mapper | LazyModule<Mapper>> =\n\tTMapper extends LazyModule<Mapper>\n\t\t? Awaited<ReturnType<TMapper>> extends {\n\t\t\t\tdefault: unknown;\n\t\t  }\n\t\t\t? Awaited<ReturnType<TMapper>>[\"default\"]\n\t\t\t: Awaited<ReturnType<TMapper>>\n\t\t: TMapper;\n\n/**\n * Transforms a Slice into its mapped version.\n */\ntype MapSliceLike<\n\tTSliceLike extends SliceLike,\n\tTMappers extends Mappers,\n> = TSliceLike extends Slice\n\t? TSliceLike[\"slice_type\"] extends keyof TMappers\n\t\t? SliceLikeRestV2<TSliceLike[\"slice_type\"]> &\n\t\t\t\tMappedSliceLike &\n\t\t\t\tAwaited<\n\t\t\t\t\tReturnType<\n\t\t\t\t\t\tResolveLazyMapperModule<TMappers[TSliceLike[\"slice_type\"]]>\n\t\t\t\t\t>\n\t\t\t\t>\n\t\t: TSliceLike\n\t: TSliceLike extends SliceLikeGraphQL\n\t? TSliceLike[\"type\"] extends keyof TMappers\n\t\t? SliceLikeGraphQL<TSliceLike[\"type\"]> &\n\t\t\t\tMappedSliceLike &\n\t\t\t\tAwaited<\n\t\t\t\t\tReturnType<ResolveLazyMapperModule<TMappers[TSliceLike[\"type\"]]>>\n\t\t\t\t>\n\t\t: TSliceLike\n\t: never;\n\n/**\n * Transforms a Slice Zone using a set of mapping functions, one for each type\n * of Slice. Mapping functions can be async.\n *\n * Whenever possible, use this function on the server to minimize client-side\n * processing.\n *\n * @example\n *\n * ```typescript\n * const mappedSliceZone = await unstable_mapSliceZone(page.data.slices, {\n * \tcode_block: ({ slice }) => ({\n * \t\tcodeHTML: await highlight(slice.primary.code),\n * \t}),\n * });\n * ```\n *\n * @experimental Names and implementations may change in the future.\n * `unstable_mapSliceZone()` does not follow SemVer.\n */\nexport function unstable_mapSliceZone<\n\tTSliceLike extends SliceLike,\n\tTMappers extends Mappers,\n\tTContext = unknown,\n>(\n\tsliceZone: SliceZoneLike<TSliceLike>,\n\tmappers: TMappers,\n\tcontext?: TContext,\n): Promise<MapSliceLike<TSliceLike, TMappers>[]> {\n\treturn Promise.all(\n\t\tsliceZone.map(async (slice, index, slices) => {\n\t\t\tconst isRestSliceType = \"slice_type\" in slice;\n\t\t\tconst sliceType = isRestSliceType ? slice.slice_type : slice.type;\n\n\t\t\tconst mapper = mappers[sliceType];\n\n\t\t\tif (!mapper) {\n\t\t\t\treturn slice;\n\t\t\t}\n\n\t\t\tconst mapperArgs = { slice, slices, index, context };\n\n\t\t\t// `result` may be a mapper function OR a module\n\t\t\t// containing a mapper function.\n\t\t\tlet result = await mapper(mapperArgs);\n\n\t\t\t// `result` is a module containing a mapper function,\n\t\t\t// we need to dig out the mapper function. `result`\n\t\t\t// will be reassigned with the mapper function's value.\n\t\t\tif (\n\t\t\t\t// `mapper.length < 1` ensures the given\n\t\t\t\t// function is something of the form:\n\t\t\t\t// `() => import(...)`\n\t\t\t\tmapper.length < 1 &&\n\t\t\t\t(typeof result === \"function\" ||\n\t\t\t\t\t(typeof result === \"object\" && \"default\" in result))\n\t\t\t) {\n\t\t\t\tresult = \"default\" in result ? result.default : result;\n\t\t\t\tresult = await result(mapperArgs);\n\t\t\t}\n\n\t\t\tif (isRestSliceType) {\n\t\t\t\treturn {\n\t\t\t\t\t__mapped: true,\n\t\t\t\t\tid: slice.id,\n\t\t\t\t\tslice_type: sliceType,\n\t\t\t\t\t...result,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\t__mapped: true,\n\t\t\t\t\ttype: sliceType,\n\t\t\t\t\t...result,\n\t\t\t\t};\n\t\t\t}\n\t\t}),\n\t);\n}\n"],"names":[],"mappings":";;AA8NgB,SAAA,sBAKf,WACA,SACA,SAAkB;AAElB,SAAO,QAAQ,IACd,UAAU,IAAI,OAAO,OAAO,OAAO,WAAU;AAC5C,UAAM,kBAAkB,gBAAgB;AACxC,UAAM,YAAY,kBAAkB,MAAM,aAAa,MAAM;AAEvD,UAAA,SAAS,QAAQ,SAAS;AAEhC,QAAI,CAAC,QAAQ;AACL,aAAA;AAAA,IACP;AAED,UAAM,aAAa,EAAE,OAAO,QAAQ,OAAO,QAAO;AAI9C,QAAA,SAAS,MAAM,OAAO,UAAU;AAKpC;AAAA;AAAA;AAAA;AAAA,MAIC,OAAO,SAAS,MACf,OAAO,WAAW,cACjB,OAAO,WAAW,YAAY,aAAa;AAAA,MAC5C;AACQ,eAAA,aAAa,SAAS,OAAO,UAAU;AACvC,eAAA,MAAM,OAAO,UAAU;AAAA,IAChC;AAED,QAAI,iBAAiB;AACb,aAAA;AAAA,QACN,UAAU;AAAA,QACV,IAAI,MAAM;AAAA,QACV,YAAY;AAAA,QACZ,GAAG;AAAA,MAAA;AAAA,WAEE;AACC,aAAA;AAAA,QACN,UAAU;AAAA,QACV,MAAM;AAAA,QACN,GAAG;AAAA,MAAA;AAAA,IAEJ;AAAA,EACD,CAAA,CAAC;AAEJ;;"}